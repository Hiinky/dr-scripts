=begin
  Documentation: https://elanthipedia.play.net/Lich_script_development#sorter
=end

custom_require.call(%w[common common-items])
require 'terminal-table'

class Sorter
  def initialize(use_table)
    @settings = get_settings
    @settings.sorter['ignore_categories'] ||= 'nil'
    @use_table = use_table
    setup_downstream_hook
  end

  def setup_downstream_hook
    action = proc { |line| process_line(line) }
    DownstreamHook.add('sorter', action)
  end

  def process_line(line)
    if line =~ /^(You rummage .*? and see .*?|You rummage .*? but there is nothing in there\.)/
      container_name, items = parse_rummage_output(line)
      sorted_items = sort_items(items)
      @use_table ? display_table(sorted_items, container_name) : display_default(sorted_items, container_name)
      nil # Suppress the original line output
    elsif line =~ /(?:In|On|Behind|Under) (?:an?|the) (.*?) you see (.*)\./
      container_name = Regexp.last_match(1).strip
      contents = Regexp.last_match(2)
      items = DRC.list_to_array(contents)
      sorted_items = sort_items(items)
      @use_table ? display_table(sorted_items, container_name) : display_default(sorted_items, container_name)
      nil # Suppress the original line output
    elsif line =~ /^On (?:an?|the) (.*?), you see:/
      container_name = $1.strip
      shop_items = []
      while (item_line = get) !~ /\[Type SHOP \[GOOD\] or click an item to see some details about it\.\]/
        if item_line =~ /<d cmd='shop #\d+ on #\d+'>(.*?)<\/d>/
          shop_items << $1.strip
        end
      end
      sorted_items = sort_shop_items(shop_items)
      display_shop_table(sorted_items, container_name)
      nil
    else
      line # Allow non-matching lines to pass through
    end
  end

  def parse_rummage_output(line)
    if line =~ /^You rummage through (.*?) and see (.*)\./
      container_name = $1
      items = DRC.list_to_array($2)
      return container_name, items
    elsif line =~ /^You rummage through (.*?) but there is nothing in there\./
      container_name = $1
      return container_name, []
    end
  end

  def sort_items(items)
    sorted = {}
    items.each do |item|
      clean_item = item.sub(/^\s*?\b(?:a|an|some|and|the)\b\s/, '').chomp('.').strip
      noun = DRC.get_noun(clean_item)
      type = get_item_type(clean_item, noun)

      if sorted[type]
        if sorted[type][clean_item]
          sorted[type][clean_item][:qty] += 1
        else
          sorted[type][clean_item] = { noun: noun, qty: 1, full_description: item.chomp('.').strip }
        end
      else
        sorted[type] = { clean_item => { noun: noun, qty: 1, full_description: item.chomp('.').strip } }
      end
    end
    sorted
  end

  def sort_shop_items(items)
    sorted = {}
    items.each do |item|
      if item =~ /(.*) for (.*?) (.*?) Kronars$/
        full_description = $1.strip
        price = $2
        currency = $3
        clean_item = full_description.sub(/^\s*?\b(?:a|an|some|and|the)\b\s/, '')
        noun = DRC.get_noun(clean_item)
        type = get_item_type(clean_item, noun)
        sorted[type] ||= {}
        sorted[type][clean_item] = { 
          noun: noun,
          price: "#{price} #{currency}",
          full_description: full_description
        }
      end
    end
    sorted
  end

  def get_item_type(item, noun)
    item_data = get_data('sorting').to_h.merge(get_data('items').to_h)
    category = 'Other'

    item_data.each do |key, value|
      if noun =~ /#{value.join('$|').concat('$')}/i || item =~ /(?:#{value.join('$|').concat('$')})/i
        category = key.to_s.sub(/_nouns|_types/, '').capitalize
        break
      end
    end

    category
  end

  def display_table(sorted_items, container_name)
    table = Terminal::Table.new do |t|
      t.title = "Contents of #{container_name.strip}"
      t.style = { border_x: "-", border_i: "+", border_y: "|" }

      if sorted_items.empty?
        t << [{ value: "This container is empty", alignment: :center, colspan: 2 }]
      else
        t.headings = ['Item', 'Qty.']
        sorted_types = sorted_items.keys.sort_by { |type| type == "Other" ? [1, type] : [0, type] }

        sorted_types.each do |type|
          items = sorted_items[type]
          t << :separator
          t << [{ value: type.strip, alignment: :center, colspan: 2 }]
          t << :separator
          items.each do |data|
            t << [data[:full_description].strip, data[:qty]]
          end
        end
      end
    end

    table_string = table.to_s.gsub('[[MONSTERBOLD]]', monsterbold_start).gsub('[[/MONSTERBOLD]]', monsterbold_end)
    Lich::Messaging.mono(table_string)
  end

  def display_shop_table(sorted_items, container_name)
    table = Terminal::Table.new do |t|
      t.title = "Items for sale on #{container_name}"
      t.headings = ['Item', 'Type', 'Price']
      sorted_items.each do |type, items|
        t << :separator
        t << [{ value: type, alignment: :center, colspan: 3 }]
        t << :separator
        items.each do |data|
          t << [data[:full_description], data[:noun], data[:price]]
        end
      end
    end
    
    Lich::Messaging.mono(table.to_s)
  end

  def display_default(sorted_items, container_name)
    output = "#{container_name}:\n"
    sorted_items.sort.each do |category_name, category_contents|
      count = category_contents.values.sum { |item| item[:qty] }
      output << "#{monsterbold_start}#{category_name} (#{count}):#{monsterbold_end} "
      category_contents.each do |_item, data|
        output << if data[:qty] > 1
                    "#{data[:full_description]} (#{data[:qty]}), "
                  else
                    "#{data[:full_description]}, "
                  end
      end
      output.chomp!(', ')
      output << ".\n"
    end
    Lich::Messaging.mono(output)
  end

  def cleanup_hook
    DownstreamHook.remove('sorter')
  end
end

use_table = script.vars.include?('table')
sorter_instance = Sorter.new(use_table)

begin
  # Keep the script running in the background to monitor incoming lines.
  while true; sleep(0.1); end
ensure
  sorter_instance.cleanup_hook # Clean up when the script exits.
end
